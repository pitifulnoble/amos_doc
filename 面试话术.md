
# 自我介绍
面试官您好，我叫xxx，今天来面试后端开发工程师岗位，从事这一行有4年多时间。

之前在字节跳动任职，在字节内部有过一次职级晋升。主要从事内容安全系统建设，包括长视频审核系统、云视频会议审核系统建设等，是内容安全产品的主要研发角色。后面也参与过TikTok产品后端研发的工作，模板方向。

在字节主要使用的开发语言是go，3年前在小米有使用过一年java 如果团队使用Java 我也能比较快速熟悉起来，常用的中间件包括Mysql、Redis等主流数据库，Kafka、RocketMQ等消息中间件。
我对技术抱有热情，在字节工作期间，申请过2个专利。

Hello, interviewer. My name is xxx. I am here today to interview for the position of backend development engineer. I have been working in this field for more than 4 years.

I worked in ByteDance before and was promoted once within ByteDance. I am mainly engaged in the construction of content security systems, including the construction of long video review systems and cloud video conference review systems. I am the main R&D role of content security products. Later, I also participated in the backend R&D of TikTok products, in the template direction.

The main development language used in ByteDance is go. Commonly used middleware includes mainstream databases such as Mysql and Redis, and message middleware such as Kafka and RocketMQ. I am passionate about technology and applied for 2 patents during my work at ByteDance.


# 描述一下第一个项目：

在TikTok团队主要做模版方向的后端研发。模版可以简单理解为一堆特效的打包。用户上传一些视频图片素材到模板，即可快速复用这些特效，生产一个高制作的短视频。我主要做2个事情，使用DSL流程模块化模板的下发服务，下发包括模板的运用信息(不同地区是否可以下发、分类信息)，地区的合规版权信息，用户隐私信息。

模板下发有不同的入口：模板广场、锚点、一件成片等。不同的入库涉及到不同的业务团队。所以DSL模块化有个根本目标是统一开发流程，代码规范。

标签系统介绍：所有模版创作后，都需要打标做分类，用于后续的分发场景。主要有2个关键事情，模板依据内置素材做视频合成(看看这个制作的模板，复用的效果是类似的)，将视频送到TCS平台做人工打标。项目中涉及到任务状态的变化。任务节点变化比较明确，没有使用消息队列。

历史的坑：
1. 2套ID系统
2. 团队不稳定换了3个领导


In the TikTok team, I mainly do backend R&D in the direction of templates. Templates can be simply understood as a package of special effects. Users upload some video and picture materials to the template, and then they can quickly reuse these special effects to produce a high-quality short video. I mainly do two things, using the DSL process to modularize the template distribution service, including the use of templates (whether it can be delivered in different regions, classification information), regional compliance copyright information, and user privacy information.

There are different entrances for template distribution: template square, anchor point, autocut, etc. Different entrances involves different teams. Therefore, the fundamental goal of DSL modularization is to unify the development process and code standards.

Introduction to the label system: After all templates are created, they need to be set labels for distingush. There are two key things: First make a short vide by using this template with some inner material (take a look at the template made, if the effect of reuse is similar), and sends the video to the TCS platform for manual labeling. The project involves changes in task status. The changes in task nodes are relatively clear, and no message queue is used.

# 描述一下第二个项目：
多模态内容安全审核系统 是我在字节维护时间最长的一个项目。支持长视频，限制6小时，音频，图片，文本审核。以最复杂的视频为例，我们亚对一个视频审核。会将视频拆分为图片、音频段、文本这些模态分别审核，原视频的审核结果就是这些单模态的聚合。

产品接口上，用户提供视频URL，审核完成后，我们异步调用用户通知结果。约定时间2小时。

业务流程较多，为了保障任务的成功，异常恢复能力。技术实现上，使用的是工作流，各个任务节点使用RocketMQ串联。稳定性上主要使用RocketMQ 退避重试算法实现。继续深入细节，从一个任务提交开始，写入一条任务信息到Mysql，同时决定要审核的模态，写入多条模态审核任务到mysql另一张表，会先将原视频链接提交到内部的视频中台，做图片抽针，音频截断。这些事情做完之后，我们服务收到通知，生成各个图片、音频断的审核任务，发送一批mq消息。各个后续节点消费mq消息做审核任务，以图片为例，ocr提取文本，图片和文本一起送入规则引擎平台同步调用获取审核结果，然后这个结果存储在redis中，后续节点判断当前这个模态是否审核完毕，如果没有就正常退出，如果完毕就合并单模态的审核结果，然后写入Mysql模态任务表中，判断所有模态是否都成功，成功后合并所有模态结果到总任务表中。后续节点发送结果给用户，还有些后置处理，监控指标等。


The multimodal content security review system is the project I have maintained the longest at ByteDance. It supports long videos, limited to 6 hours. Taking the most complex video as an example, we review a video. The video will be split into images, audio segments, and text for review. The review result of the original video is the aggregation of these single modes.

On the product interface, the user provides the video URL. We send result to user asynchronously. The agreed time is 2 hours.

There are many business processes. In order to ensure the success of the task and the ability to recover from interruption. In terms of technical implementation, workflow is used, and each task node is connected by RocketMQ. In terms of stability, RocketMQ backoff and retry algorithm is mainly used to achieve it. 

Let's go into the details. Starting from a task submission, a task message is written to Mysql. At the same time, which multiple modal reviewed is determined, and multiple modal review tasks are written to another table in MySQL. The original video link will be submitted to the video middle platform first to extract the image and cut the audio. After these things are done, our service receives a notification, generates review tasks for each image and audio, and sends a batch of mq messages. Each subsequent node consumes mq messages to perform review tasks. Taking pictures as an example, OCR extracts text, and the pictures and text are sent to the rule engine platform for synchronous call to obtain the review results. Then the results are stored in redis. Then check if all images tasks have been reviewed. If not, just return. If completed, the review results of the single modality are merged, and then written to the Mysql modal task table to determine whether all modalities are successful. After success, all modal results are merged into the total task table. Subsequent nodes send results to users, and there are also some post-processing, monitoring indicators, etc.

# 描述一下第三个项目：
RTC就是一种在线多人音视频产品。审核就是在审核这些线上实时音视频。对于我们，RTC厂商就是客户，让这些客户的RTC产品支持安全审核能力。

业务形态上面，我们已经支持直播内容审核的能力，所以我们需要能拉取线上实时音视频流切出图片和音频段，然后送审到现有系统就行。一群人在一起RTC实时音视频交流，这就是一个房间，我们把服务划分2层Adapter负责管理任务状态，具体执行层Excutor实际上做音频图片的抽针。抽针需要我们加入到线上房间中，这需要我们接入RTC厂商的SDK，一般这种音视频开发主流编程语言是C++，RTC厂商也一般都会提供C++的sdk，所以对Excutor进一步分层。主业务加入房间拉取直播流，图片音频切针使用C++实现，定义为transcode层。具体任务中管理，TOS对象写，回调处理使用常用GO来实现，定义为Excutor层。

RTC(Real-time Communications). we review these online real-time audio and video. For us, RTC manufacturers are customers, and we need to make their RTC products support security audit capabilities.

In terms of business form, we already support the ability to review live content, so we need to be able to pull the online real-time audio and video stream, cut out the picture and audio segment, and then submit it to the existing system for review. A group of people are communicating with each other in real-time audio and video through RTC. This is a room. We divide the service into two layers. The Adapter is responsible for managing the task status, and the specific execution layer Executor actually extracts the audio and picture. Extracting the needle requires us to join the online room, which requires us to access the SDK of the RTC manufacturer. Generally, the mainstream programming language for this kind of audio and video development is C++, and RTC manufacturers generally provide C++ SDKs, so the Executor is further layered. The main business joins the room to pull the live stream, and the picture and audio needle cutting is implemented in C++, which is defined as the transcode layer. Management in specific tasks, TOS object writing, and callback processing are implemented using common GO, which is defined as the Executor layer.


