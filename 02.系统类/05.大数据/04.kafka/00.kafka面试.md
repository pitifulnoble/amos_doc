
## 问题
为什么要使用消息队列？
如何保证消息的顺序性？
如何避免消息重复消费？
大量消息在 MQ 里长时间积压，该如何解决？
MQ 中的消息过期失效了怎么办？

## 如何保证消息的顺序性
Kafka 的一个主题（Topic）可以分为多个分区（Partition），每个分区内的消息是按照写入的先后顺序存储的，并且在分区内消息是严格有序的。

**生产者**
当生产者向 Kafka 发送消息时，如果指定了特定的分区，那么这些消息就会按照发送的顺序依次写入到该分区中，消费者从这个分区读取消息时，也会按照写入的顺序依次读取出来，从而保证了在分区级别上消息的顺序性。
比如有一个名为 “orders” 的主题，用于处理订单相关消息。可以根据订单 ID 的哈希值对订单消息进行分区，这样同一个订单的所有消息就会被发送到同一个分区中，进而在该分区内保证这些与同一订单相关消息的顺序性。

**消费者**
分区分配与消费协调：当有多个消费者组成消费者组（Consumer Group）共同消费一个主题时，Kafka 会根据分区分配策略将主题的各个分区分配给不同的消费者。为了保证消息顺序性，需要注意分区分配的合理性。例如，尽量让相关的分区分配给同一个消费者进行处理，避免出现同一个业务逻辑相关的消息被不同消费者打乱顺序处理的情况。同时，消费者在处理消息时，要按照从分区中读取的顺序依次进行处理，不能出现跳跃式处理而破坏消息顺序。

## 如何避免消息重复消费

**生产者端控制**
幂等性设置：
Kafka 从 0.11 版本开始支持消息的幂等性生产。生产者开启幂等性后，在一定时间窗口内（默认是 1 小时），对于同一个分区、相同的键（Key）发送的消息，Kafka 会保证只有一条消息被实际写入到该分区中。
例如，当发送订单处理消息时，如果以订单编号作为键，那么在幂等性生效的时间窗口内，即便因网络波动等原因导致生产者多次发送相同订单编号对应的消息，Kafka 也只会接收并处理一次。


**消费者端控制**
消息偏移量管理：
消费者通过记录和更新所消费消息的偏移量（Offset）来确定已经消费了哪些消息以及接下来要消费的消息位置。为了避免重复消费，消费者必须准确地维护和更新偏移量。
手动提交偏移量：在消费者代码中，可以采用手动提交偏移量的方式。例如，在 Java 客户端中，当消费者成功处理完一条消息后，再手动将该消息对应的偏移量提交给 Kafka。这样可以确保只有在消息被真正处理完成后，才会将偏移量更新，避免因自动提交偏移量可能导致的消息处理中断（如程序崩溃等情况）而造成的重复消费。以下是手动提交偏移量的示例代码：


**缓存去重：**
利用缓存系统（如 Redis 等）也可以进行消息去重。在消费消息之前，先到缓存中查看是否已经存在该消息的标识（如消息 ID 等），如果存在，则说明该消息可能已经被消费过，直接跳过；如果不存在，则在缓存中记录该消息的标识，并继续消费该消息。
假设消费一个主题为 “news” 的消息，在消费每条消息前，可以先到 Redis 中查询以消息 ID 为键的记录是否存在，若存在则不消费该消息，若不存在则在 Redis 中以消息 ID 为键，设置一个过期时间（如 60 秒），然后再消费该消息。


## 大量消息在 MQ 里长时间积压，该如何解决？
**确定积压原因**

生产者生产速度过快：可能是业务增长、促销活动等原因导致生产者发送消息的速度远超过消费者处理消息的速度，使得消息在 Kafka 中不断堆积。
消费者处理能力不足：消费者的硬件资源有限（如 CPU、内存不足），或者消费逻辑过于复杂、存在性能瓶颈（如频繁的数据库操作、复杂的业务计算），导致无法及时处理接收到的消息，进而造成积压。

**临时解决方案**

- 增加消费者数量：
如果是消费者处理能力不足导致的积压，可以在消费者组中增加更多的消费者实例。Kafka 会根据分区分配策略重新分配主题的分区给新加入的消费者，从而提高整体的消费能力，加快消息处理速度。
例如，原本有 2 个消费者处理一个主题的消息，现在增加到 5 个消费者，通过合理的分区分配，每个消费者承担的消息处理量会相对减少，进而加快积压消息的处理。
- 调整消费者消费策略：
可以考虑调整消费者的消费策略，比如从按顺序逐个处理消息改为批量处理消息（如果业务允许）。批量处理能够减少一些不必要的开销（如频繁的网络交互、数据库连接建立等），提高处理效率，加快积压消息的处理速度。
假设原来消费者是一条一条地处理订单消息，现在可以尝试将订单消息每 10 条作为一批进行处理，对这一批消息统一进行业务操作（如批量更新数据库记录等）。


## MQ 中的消息过期失效了怎么办？
