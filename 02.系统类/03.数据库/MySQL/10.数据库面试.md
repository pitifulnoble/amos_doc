# 数据库面试
![fail](https://cdn.jsdelivr.net/gh/pitifulnoble/picture@master/acf18f0bd9d2847aef1939bec04b31e3.png)
- 如何设计一个数据库
- 为什么要使用索引
- 什么样的数据适合做索引
- 索引的数据结构
- 如何调优 sql
- 联合索引最左匹配 原则
- 索引是建立的越多越好吗
- 数据库三大范式，以及其作用


## 如何设计一个数据库
![fail](https://cdn.jsdelivr.net/gh/pitifulnoble/picture@master/acacf2622cf039991f98671a1a3a3b45.png)

- 考察复杂问题分模块能力和数据库架构了解

首先分成2大模块，数据存储模块和程序实例模块。存储模块用于存储数据，程序实例模块让我们能很好的使用数据。
程序实例中要有存储管理，让我们能操作存储模块的数据。
缓存机制，磁盘读写IO很慢，数据操作一定是在内存中。通过缓存机制减少IO操作
SQL解析模块
日志管理-数据库需要有能恢复的binlog日志
权限划分-
容灾机制-数据库发生异常时如和处理，恢复到什么程度
索引和锁

## 数据结构

### 1.二分搜索树&红黑树
此类树太深，深度没增加1就要增加一次IO。根本无法提高查询效率

### 2.B树
https://www.cnblogs.com/nullzx/p/8729425.html

## 2.索引
- 为什么要使用索引
### 2.2.什么样的数据能成为索引
越能更好区分数据行的数据时候做索引，特征：
- 不重复度高
- 业务逻辑经常使用该字段过滤查询

### 2.3.索引的数据结构
B+ Tree更适合做索引存储
- B+树的磁盘读写代价更低
- B+树的查询效率更加稳定
- B+树更有利于对数据库的扫描(B+树叶子节点连在一起，范围查询更加高效)

### 2.4.密集索引和稀疏索引
Innodb是密集索引，普通索引的叶子节点存储主见，查询具体数据会发生回表。

### 2.5.最左匹配原则
和联合索引相关
- mysql会一直向右匹配直到遇到范围查询(> < between like)就停止匹配，比如 ``a=3 and b=4 and c>5 and d=6``,如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。
- =和in可以乱序，比如``a=1 and b=2 and c=3``建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮助完成索引的识别

最左匹配原则的成因，使用联合索引中第一个索引建立B+树，其他索引的值保存在该B+树的叶子节点上。所以，必须使用第一个索引字段才能走该B+树。


- 覆盖索引&索引下堆

### 2.6索引是建立的越多越好吗
- 数据量小的表不需要建立索引，建立会增加额外的索引开销
- 数据变更需要维护索引，因此更多的索引意味着更多的维护成本
- 更多的索引意味着也需要更多的空间

## 3.锁
### 3.1.问题
- MyISAM与InnoDB关于锁方面的区别是什么
- 数据库事务的四大特性
- 事务隔离级别以及各级别下的并发访问问题
- InnoDB可重复读级别下如何避免幻读
- RC、RR级别下InnoDB的非阻塞读如何实现

### MyISAM与InnoDB关于锁方面的区别是什么
- MyISAM支持表级锁，不支持行级锁
- InnoDB支持行级锁和表级锁

### 数据库事务的四大特性
ACID
- 原子性(Atomic)
- 一致性(Consistency)
- 隔离性(Isolation)
- 持久性(Durabilty)

### 事务隔离级别以及各级别下的并发访问问题
**隔离级别**
- READ-UNCOMMITTED
- READ-COMMITTED
- REPEATABLE-READ(innodb 默认的隔离级别)
- Serializable

**问题**
- 脏读(一个事务读到另一个事务未提交的数据)----READ-COMMITTED事务隔离级别以上可避免
- 不可重复读(一个事务中多次读取同一个数据，但结果不一致，因为有另一个事务提交了数据)-REPEATABLE-READ事务隔离级别以上可避免
- 幻读-SERIALIZABLE事务隔离级别可避免

### 当前读&快照读
当前读：增删改，select for update等
快照读：不加锁的非阻塞读(可能读到的不是最新版本)

### RC、RR级别下InnoDB的非阻塞读如何实现
- 每行数据会记录DB_TRX_ID, DB_ROLL_PTR, DB_ROW_ID字段
- undo日志
- read view(RR级别下，首次快照读的时机非常关键，会创建read view，决定数据读取的版本)

![fail](https://cdn.jsdelivr.net/gh/pitifulnoble/picture@master/9e8efa0fa992afa2dee5519f297eaf64.png)

### InnoDB可重复读级别下如何避免幻读
- 表象：快照读(非阻塞读)---伪MVCC
- 内在：next-key锁(行锁+gap锁)
    - 如果where条件全部命中，则不会用Gap锁，只会加记录锁
    - 如果where条件部分名字或全不命中，会加Gap锁。

#### Gap锁
Gap锁的范围是针对索引B+数的叶子结点来说
Gap锁会用在非唯一索引或不走索引的当前读中
- 如果where条件全部命中，则不会用Gap锁，只会加记录锁
- 如果where条件部分名字或全不命中，会加Gap锁。

**非唯一索引**
非唯一索引，会锁未命中记录的前后B+索引的空隙。
![fail](https://cdn.jsdelivr.net/gh/pitifulnoble/picture@master/937115dfdac67e72483cfa95cef54f67.png)

**不走索引**
会对所有的gap做上锁。对插入动作来说类似是全表锁
![fail](https://cdn.jsdelivr.net/gh/pitifulnoble/picture@master/d25546b4d6e0841c82ba9f73f53a15ff.png)

## 数据库三大范式，以及其作用

数据库的三大范式是设计关系数据库结构的基本规范，目的是消除冗余数据，提高数据的一致性和完整性。它们按照复杂性逐步递进：

第一范式（1NF）：字段原子性

定义

每个字段必须是原子值，即不可再分的最小单位。
	•	不符合1NF：
表中某一列存储了多个值，例如：

```
姓名      电话  
张三      123456, 789012
```

	•	符合1NF：
将字段拆分成单一值：

```
姓名      电话  
张三      123456  
张三      789012
```


作用

	1.	消除了重复值存储问题。
	2.	数据更易于查询和管理。

第二范式（2NF）：消除部分依赖

定义

在满足1NF的基础上，表中所有非主键字段必须完全依赖于主键，不能只依赖主键的一部分。
	•	不符合2NF：
假设主键为(学号, 课程ID)，字段学生姓名只依赖于学号：

```
学号      课程ID      学生姓名      成绩  
1001      C01         张三          95  
1001      C02         张三          88  
```

	•	符合2NF：
将表拆分成两张：

```
学号      学生姓名  
1001      张三  
```

```
学号      课程ID      成绩  
1001      C01         95  
1001      C02         88  
```


作用

	1.	消除了部分冗余数据。
	2.	避免因修改或删除部分信息而导致数据不一致。

第三范式（3NF）：消除传递依赖

定义

在满足2NF的基础上，表中所有非主键字段必须直接依赖于主键，不能存在传递依赖。
	•	不符合3NF：
主键为学号，学院名称依赖于学院ID，而学院ID依赖于学号：

```
学号      学院ID      学院名称  
1001      A01         信息学院  
1002      A02         工商管理学院  
```

	•	符合3NF：
将表拆分成两张：

```
学号      学院ID  
1001      A01  
1002      A02  
```

```
学院ID      学院名称  
A01         信息学院  
A02         工商管理学院  
```


作用

	1.	消除了数据间的冗余传递关系。
	2.	进一步提高了数据的完整性和一致性。

三大范式的关系与作用总结

|范式|	要求|	作用|
|---|---|---|
|1NF|	字段原子性|	消除数据不可分的冗余，便于操作。|
|2NF|	消除部分依赖|	避免插入、更新和删除异常。|
|3NF|	消除传递依赖|	减少冗余，提高数据一致性和完整性。|

满足三大范式后，数据库结构更紧凑，冗余更少，但在实际设计中，可能为了性能适当放宽某些规范（如加入冗余字段用于快速查询）。
