# 面试题
- 1.redis 为什么这么快
- 2.说说你用过的 redis 数据类型
- 3.从海量 key 里查询固定前缀的 key
- 4.如何实现分布式锁
- 5.大量的 key 同时过期注意事项
- 6.缓存击穿、缓存穿透概念及其解决方案
- 6.如何使用 redis 做异步队列
- 7.redis 如何持久化
- 8.redis 同步机制
- 9.redis 集群原理

## redis 为什么这么快
100000+QPS（QPS 即每秒查询次数）
- 完全基于内存，绝大部分存储是基于内存操作，执行效率高
- 数据结构简单，对数据操作也简单
- 采用单线程，单线程也能处理并发请求，节省上下文切换时间。（启动多实例也可以多线程）
- 使用多路 IO 复用模型，非阻塞 IO

### 1.多路 IO 复用
#### 1.1.FD 文件描述符
File Descriptor：文件描述符
一个打开的文件通过唯一的描述符进行引用，该描述符是打开文件的元数据与文件内容的映射

#### 1.2.Redis 使用的多路复用函数
不同平台使用不同的函数，Linux 系统使用 epoll
- 优先使用时间复杂度为 O1 的函数
- 以时间复杂度为 On 的 select 作为保底
- 基于 react 设计模式监听 IO 事件
redis 使用单线程监听 FD 的读写事件，当事件发生时调用 FD 的 handle_event

## 说说你用过的 Redis 数据类型
- String 最基本的数据类型，二进制安全
- Hash 表
- List
- Set
- Sorted Set
- 用于计数的 HyperLogLog 与存储地理位置的 Geo

## 从海量 key 里查询固定前缀的 key
先询问数据规模

### 1.使用 keys 对线上业务的影响
Keys Pattern：查询所有给定模式 Pattern 的 key
- keys 指令一次返回所有指定 key
- key 的数量过大会使 redis 卡顿

Scan cursor [Match Parttern]  [Count count]
返回固定少量的 key，避免影响线上任务
- 基于游标的迭代器，需要上一次迭代的游标延续之前的迭代过程
- 以 0 作为游标开始新一次的迭代，当游标返回 0 表示数据完成一次迭代
- 不保证每次执行都返回固定数量的元素，支持模糊查询
- 一次返回的数量不可控，只能大概满足 count 的数量

## 如何实现分布式锁
SET key value [EX seconds] [PX milliseconds] [NX | XX]
- EX seconds 设置 key 的过期时间，单位是秒
- PX milliseconds 设置 key 的过期时间，单位毫秒
- NX 只在键不存在时才对键进行设置操作
- XX 只在键存在时，才对键进行设置操作
- set 操作完成时返回 OK，失败返回 nil

java 伪代码
```java
RedisServer redisServer = SpringUtils.getClient("redis");
String result = redisServer.set(lockKey,  lockId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);
if ("OK".equals(result)) {
  // 执行独占锁逻辑
}
```

## 大量 key 同时过期注意事项
如果集中删除大量 key 是需要时间的，可能会出现卡顿
解决方案，在设置过期值时加上一个随机时间，让过期时间分散。

## 缓存击穿、缓存穿透概念及其解决方案

缓存击穿和缓存穿透是分布式系统中常见的缓存问题，都会导致系统性能下降甚至瘫痪。以下是两者的概念和解决方案：

1. 缓存穿透

概念

	•	现象：
当请求的数据不存在于缓存中，且数据库中也没有时，请求会直接穿透缓存层访问数据库，导致数据库压力骤增。
	•	原因：
	•	恶意攻击：发送大量不存在的数据ID请求。
	•	用户请求错误：查询参数异常。

解决方案

	1.	布隆过滤器（Bloom Filter）
	•	在缓存层前增加布隆过滤器，将所有合法的请求Key提前存入布隆过滤器。
	•	当请求的Key不存在布隆过滤器中时，直接返回，不访问数据库。
	•	优势：高效过滤不存在的Key，占用空间小。
	2.	缓存空值
	•	如果数据库中查询结果为空，将key-null缓存到缓存层，并设置较短的过期时间。
	•	优势：防止频繁访问同一不存在的数据，减轻数据库压力。
	•	注意事项：需要合理设置过期时间，避免缓存污染。
	3.	参数校验
	•	对请求参数（如ID格式）进行校验，直接过滤非法请求。
	•	适用于存在明确请求规则的场景。
	4.	限流与IP黑名单
	•	针对恶意请求，限制单个IP的访问频率或直接将恶意IP加入黑名单。

2. 缓存击穿

概念

	•	现象：
某个热点数据在缓存过期的瞬间，大量并发请求涌入，直接访问数据库，导致数据库负载激增。
	•	原因：
	•	热点Key的访问量极大，缓存未能及时更新。

解决方案

	1.	热点数据提前预热
	•	在服务启动时，提前将热点数据加载到缓存中。
	•	优势：有效避免热点Key的冷启动问题。
	2.	加锁机制（Mutex）
	•	当缓存过期时，针对同一个Key的请求，加锁限制只有一个线程能查询数据库并更新缓存，其余线程等待。
	•	具体实现：通过分布式锁（如Redis的SETNX）或本地锁。
	•	优势：避免大量并发请求同时访问数据库。
	3.	自动续约机制
	•	在缓存接近过期时间时，后台任务自动续约热点Key的过期时间，防止其过期。
	•	例如，使用延时双删策略：
	•	删除缓存后，先更新数据库，再延迟一定时间再次删除缓存。
	4.	永不过期策略
	•	对热点Key设置“逻辑过期”，即缓存数据不过期，但在后台维护实际的过期时间。
	•	优势：前台请求不会受到缓存过期的影响，而后台任务异步更新数据。

总结：缓存穿透与缓存击穿的区别与对策

|问题|	现象|	主要原因|	解决方案|
|---|---|---|---|
|缓存穿透|	数据既不在缓存中，也不在数据库中|	请求数据不存在或非法请求|	布隆过滤器、缓存空值、参数校验、限流等|
|缓存击穿|	热点Key缓存过期，大量请求打到数据库|	热点数据高并发且缓存未及时更新|	加锁机制、自动续约、逻辑过期、预热等|

两者可以结合布隆过滤器、分布式锁和合理的缓存策略设计来有效应对，保障系统稳定性和高性能。



## 如何使用 redis 做异步队列
可以使用 list 做队列，支持先进先出/后出。问题是只能有一个消费者。
redis 同样支持多客户端订阅方式：

### 1.pub/sub：主题订阅模式
消费者：
- 监听 topic：subscribe topicName
生产者：
- 发布消息：publish topicName "message"

## 7.redis 如何持久化

### 1.RDB（快照）持久化：保存某个时间点的全量数据快照
- SAVE：阻塞 Redis 的服务进程，直到 RDB 文件被创建完毕
- GBSAVE：fork 一个子线程来创建 RDB 文件，不阻塞当前进程

### 2.自动触发 RDB
- 根据 redis.conf 里配置的 SAVE m n 定时触发（用的是 BGSAVE）
- 主从复制，主节点自动触发
- 执行 Debug Reload
- 执行 Shutdown 且没有设置 AOF 持久化

### 3.GBSAVE 在 fork 子线程的细节
fork 函数使用 Copy-On-Write 优化
如果有多个调用者需要相同的资源（如内存或磁盘上的数据存储），它们会获取相同的指针指向共同的资源地址。直到某个调用者试图修改其中的资源，系统才会真正复制一份给这个调用者，而其他调用者看到的资源依旧不变。

### 4.RDB 问题
- 内存全量复制，数据量大可以因为 IO 瓶颈影响性能。
- 可能会因为 redis 挂掉而丢失当前数据到上一次快照之间的数据。

### 5.AOF 持久化
AOF 类似 mysql 的 binlog 日志，通过记录写命令来备份数据。

### 6.AOF 日志不断增大问题
比如一个 key 自增 100 次，但只要写一条命令就够了但 AOF 或记录所有的自增命令。
解决方法重写 AOF 日志
- 调用 fork(),创建一个子线程
- 子线程把新的 AOF 日志写入一个文件中，不依赖原有 AOF 日志，只依赖当前 redis 存储数据
- 主进程持续将新的变动写入内存和原 AOF 文件中。
- 主进程获取子进程重新 AOF 完成信号，往新 AOF 增量变动
- 使用新 AOF 替换原 AOF 文件

### 7.AOF 与 RDB 比较
- RDB 文件是二进制快照比 AOF 体积小，数据恢复快
- RDB 无法保存一个快照之后的数据
- AOF 是可读命令文件，体积比 RDB 大，恢复数据慢
- AOF 是增量保存，不易丢失数据

### 8.AOF+RDB 混合备份方式
是现在 reids 的默认持久化方式
- BGSAVE 做镜像全量吃就好，AOF 做增量持久化

## pipeline机制
- Pipeline和Linux的管道类似
- Redis基于请求/响应模型，单个请求处理需要—一应答
- Pipeline批量执行指令，节省多次IO往返的时间
- 有顺序依赖的指令建议分批发送

## 8.redis 同步机制
- Master 接收到用户的操作指令，判断是否要同步到 slave 节点
- 将操作记录追加到 AOF 文件中
- 将操作传播其它 slave：1.对其主从库；2.往响应缓存中写入指令
- 将缓存数据发送给 slave

### 1.redis 哨兵-Sentinel
redis 集群模式中，如果主节点宕机，就没办法提供写操作
- 监控：检查主从服务器是否工作正常
- 通知：通过 API 通常工程师或应用程序故障发生
- 故障迁移：通过投票主从替换，类似 zk

## 9.redis 集群原理
集群一定是将数据分散存储的。
redis 使用一致性 Hash 算法：将集群节点的唯一 key(如 ip 主机名)对 2^32 取模，将地址空间练成一个圆环。将 redis 节点放入这个圆环上。写入数据时对数据做 Hash，存储到顺时针方向最近的 redis 节点中。
当需要删除节点或新增节点，只影响一个或不到一个节点上的数据。

![fail](https://cdn.jsdelivr.net/gh/pitifulnoble/picture@master/687391734ffb39ad7651654bb751fc00.png)
