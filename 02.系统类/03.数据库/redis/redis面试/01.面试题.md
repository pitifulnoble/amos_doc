# 面试题
- 1.redis 为什么这么快
- 2.说说你用过的 redis 数据类型
- 3.从海量 key 里查询固定前缀的 key
- 4.如何实现分布式锁
- 5.大量的 key 同时过期注意事项
- 6.如何使用 redis 做异步队列
- 7.redis 如何持久化
- 8.redis 同步机制
- 9.redis 集群原理

## redis 为什么这么快
100000+QPS（QPS 即每秒查询次数）
- 完全基于内存，绝大部分存储是基于内存操作，执行效率高
- 数据结构简单，对数据操作也简单
- 采用单线程，单线程也能处理并发请求，节省上下文切换时间。（启动多实例也可以多线程）
- 使用多路 IO 复用模型，非阻塞 IO

### 1.多路 IO 复用
#### 1.1.FD 文件描述符
File Descriptor：文件描述符
一个打开的文件通过唯一的描述符进行引用，该描述符是打开文件的元数据与文件内容的映射

#### 1.2.Redis 使用的多路复用函数
不同平台使用不同的函数，Linux 系统使用 epoll
- 优先使用时间复杂度为 O1 的函数
- 以时间复杂度为 On 的 select 作为保底
- 基于 react 设计模式监听 IO 事件
redis 使用单线程监听 FD 的读写事件，当事件发生时调用 FD 的 handle_event

## 说说你用过的 Redis 数据类型
- String 最基本的数据类型，二进制安全
- Hash 表
- List
- Set
- Sorted Set
- 用于计数的 HyperLogLog 与存储地理位置的 Geo

## 从海量 key 里查询固定前缀的 key
先询问数据规模

### 1.使用 keys 对线上业务的影响
Keys Pattern：查询所有给定模式 Pattern 的 key
- keys 指令一次返回所有指定 key
- key 的数量过大会使 redis 卡顿

Scan cursor [Match Parttern]  [Count count]
返回固定少量的 key，避免影响线上任务
- 基于游标的迭代器，需要上一次迭代的游标延续之前的迭代过程
- 以 0 作为游标开始新一次的迭代，当游标返回 0 表示数据完成一次迭代
- 不保证每次执行都返回固定数量的元素，支持模糊查询
- 一次返回的数量不可控，只能大概满足 count 的数量

## 如何实现分布式锁
SET key value [EX seconds] [PX milliseconds] [NX | XX]
- EX seconds 设置 key 的过期时间，单位是秒
- PX milliseconds 设置 key 的过期时间，单位毫秒
- NX 只在键不存在时才对键进行设置操作
- XX 只在键存在时，才对键进行设置操作
- set 操作完成时返回 OK，失败返回 nil

java 伪代码
```java
RedisServer redisServer = SpringUtils.getClient("redis");
String result = redisServer.set(lockKey,  lockId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);
if ("OK".equals(result)) {
  // 执行独占锁逻辑
}
```

## 大量 key 同时过期注意事项
如果集中删除大量 key 是需要时间的，可能会出现卡顿
解决方案，在设置过期值时加上一个随机时间，让过期时间分散。

## 如何使用 redis 做异步队列
可以使用 list 做队列，支持先进先出/后出。问题是只能有一个消费者。
redis 同样支持多客户端订阅方式：

### 1.pub/sub：主题订阅模式
消费者：
- 监听 topic：subscribe topicName
生产者：
- 发布消息：publish topicName "message"

## 7.redis 如何持久化

### 1.RDB（快照）持久化：保存某个时间点的全量数据快照
- SAVE：阻塞 Redis 的服务进程，直到 RDB 文件被创建完毕
- GBSAVE：fork 一个子线程来创建 RDB 文件，不阻塞当前进程

### 2.自动触发 RDB
- 根据 redis.conf 里配置的 SAVE m n 定时触发（用的是 BGSAVE）
- 主从复制，主节点自动触发
- 执行 Debug Reload
- 执行 Shutdown 且没有设置 AOF 持久化

### 3.GBSAVE 在 fork 子线程的细节
fork 函数使用 Copy-On-Write 优化
如果有多个调用者需要相同的资源（如内存或磁盘上的数据存储），它们会获取相同的指针指向共同的资源地址。直到某个调用者试图修改其中的资源，系统才会真正复制一份给这个调用者，而其他调用者看到的资源依旧不变。

### 4.RDB 问题
- 内存全量复制，数据量大可以因为 IO 瓶颈影响性能。
- 可能会因为 redis 挂掉而丢失当前数据到上一次快照之间的数据。

### 5.AOF 持久化
AOF 类似 mysql 的 binlog 日志，通过记录写命令来备份数据。

### 6.AOF 日志不断增大问题
比如一个 key 自增 100 次，但只要写一条命令就够了但 AOF 或记录所有的自增命令。
解决方法重写 AOF 日志
- 调用 fork(),创建一个子线程
- 子线程把新的 AOF 日志写入一个文件中，不依赖原有 AOF 日志，只依赖当前 redis 存储数据
- 主进程持续将新的变动写入内存和原 AOF 文件中。
- 主进程获取子进程重新 AOF 完成信号，往新 AOF 增量变动
- 使用新 AOF 替换原 AOF 文件

### 7.AOF 与 RDB 比较
- RDB 文件是二进制快照比 AOF 体积小，数据恢复快
- RDB 无法保存一个快照之后的数据
- AOF 是可读命令文件，体积比 RDB 大，恢复数据慢
- AOF 是增量保存，不易丢失数据

### 8.AOF+RDB 混合备份方式
是现在 reids 的默认持久化方式
- BGSAVE 做镜像全量吃就好，AOF 做增量持久化

## pipeline机制
- Pipeline和Linux的管道类似
- Redis基于请求/响应模型，单个请求处理需要—一应答
- Pipeline批量执行指令，节省多次IO往返的时间
- 有顺序依赖的指令建议分批发送

## 8.redis 同步机制
- Master 接收到用户的操作指令，判断是否要同步到 slave 节点
- 将操作记录追加到 AOF 文件中
- 将操作传播其它 slave：1.对其主从库；2.往响应缓存中写入指令
- 将缓存数据发送给 slave

### 1.redis 哨兵-Sentinel
redis 集群模式中，如果主节点宕机，就没办法提供写操作
- 监控：检查主从服务器是否工作正常
- 通知：通过 API 通常工程师或应用程序故障发生
- 故障迁移：通过投票主从替换，类似 zk

## 9.redis 集群原理
集群一定是将数据分散存储的。
redis 使用一致性 Hash 算法：将集群节点的唯一 key(如 ip 主机名)对 2^32 取模，将地址空间练成一个圆环。将 redis 节点放入这个圆环上。写入数据时对数据做 Hash，存储到顺时针方向最近的 redis 节点中。
当需要删除节点或新增节点，只影响一个或不到一个节点上的数据。

![fail](https://cdn.jsdelivr.net/gh/pitifulnoble/picture@master/687391734ffb39ad7651654bb751fc00.png)
