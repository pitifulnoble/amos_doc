# 单例模式
https://time.geekbang.org/column/article/194035
https://time.geekbang.org/column/article/194068
https://time.geekbang.org/column/article/196790
## 01.使用单例模式的原因
- 1.常规业务需要
- 2.解决并发问题

### 1.1.业务需要
从业务概念上，如果有些数据在系统中只应保存一份，那就比较适合设计为单例类。
比如，配置信息类。在系统中，我们只有一个配置文件，当配置文件被加载到内存之后，以对象的形式存在，也理所应当只有一份。

### 1.2.并发问题
多线程环境下，两个线程同时修改资源A，它们的修改是有可能覆盖的。

这个时候，我们一般会想到加锁。
```java
public void log(String message) { 
  synchronized(this) {
       writer.write(mesasge); 
   } 
 }
```
上图使用的是实例锁，如果目标对象不是单例模式，这种锁就起不了作用。我们需要换成对象锁：
```java
public void log(String message){
   synchronized(Logger.class) { 
      // 类级别的锁 
      writer.write(mesasge);
   }
}
```

除了使用类级别锁之外，实际上，解决资源竞争问题的办法还有很多，分布式锁是最常听到的一种解决方案。不过，实现一个安全可靠、无 bug、高性能的分布式锁，并不是件容易的事情。除此之外，并发队列（比如 Java 中的 BlockingQueue）也可以解决这个问题：多个线程同时往并发队列里写日志，一个单独的线程负责将并发队列中的数据，写入到日志文件。这种方式实现起来也稍微有点复杂。

相对于这两种解决方案，单例模式的解决思路就简单一些了。单例模式相对于之前类级别锁的好处是，不用创建那么多 Logger 对象，一方面节省内存空间，另一方面节省系统文件句柄（对于操作系统来说，文件句柄也是一种资源，不能随便浪费）。

我们将 Logger 设计成一个单例类，程序中只允许创建一个 Logger 对象，所有的线程共享使用的这一个 Logger 对象，共享一个 FileWriter 对象，而 FileWriter 本身是对象级别线程安全的，也就避免了多线程情况下写日志会互相覆盖的问题。

### 1.3.饿汉还是懒汉好
有人觉得这种实现方式不好，因为不支持延迟加载，如果实例占用资源多（比如占用内存多）或初始化耗时长（比如需要加载各种配置文件），提前初始化实例是一种浪费资源的行为。最好的方法应该在用到的时候再去初始化。不过，我个人并不认同这样的观点。

如果初始化耗时长，那我们最好不要等到真正要用它的时候，才去执行这个耗时长的初始化过程，这会影响到系统的性能（比如，在响应客户端接口请求的时候，做这个初始化操作，会导致此请求的响应时间变长，甚至超时）。采用饿汉式实现方式，将耗时的初始化操作，提前到程序启动的时候完成，这样就能避免在程序运行的时候，再去初始化导致的性能问题。

如果实例占用资源多，按照 fail-fast 的设计原则（有问题及早暴露），那我们也希望在程序启动时就将这个实例初始化好。如果资源不够，就会在程序启动的时候触发报错（比如 Java 中的 PermGen Space OOM），我们可以立即去修复。这样也能避免在程序运行一段时间后，突然因为初始化这个实例占用资源过多，导致系统崩溃，影响系统的可用性。

## 02.单例模式存在的问题

- 1.单例对OOP支持不友好
- 2.单例会隐藏类之间的调用关系
- 3.单例对代码的扩展性不友好
- 4.单例对代码的可测性不友好
- 5.单例不支持参数构造函数