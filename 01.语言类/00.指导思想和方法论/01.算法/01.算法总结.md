# 算法总结

## 0.算法复杂度

如何判断一个算法的复杂度？

答案：经验。

- O(logn):类似二分查找法，处理完一个动作后，后续要处理的数据量为n/a（a是常数，二分查找法中a=2）。这类就是logn级别算法。
- O(n):类似数组便利，数据量n，每个元素都需要执行一次操作。
- O(n^2):常见的双重循环，数量级n中每个元素都需要和整体an级别的元素做一次操作。
- O(2^n):每个数据操作后，都需要和an级别数据做运算。通常算法最终答案不太可能是它。



不同数量级，推荐用什么复杂度算法可以参考下面这些经验：

- O(logn):无限
- O(n):1s内完成：10^8级别的数据
- O(nlogn):1s内完成：10^7级别数据
- O(n^2):1s内完成：10^4级别数据
- O(2^n):1s内完成：20



## 1.数组类问题
- 1.对撞指针
- 2.滑动窗口
- 3.int[256]记录

## 2.查找类问题
需要使用set或map的问题.<br>
**最重要的是分析我们要记录的是什么?**<br>
经典问题:twosum:[https://leetcode-cn.com/problems/two-sum/](https://leetcode-cn.com/problems/two-sum/)<br>

## 3.链表类问题
- 1.多指针记录
- 2.虚拟头节点
- 3.特殊情况,强调是特殊情况,可以考虑更改节点的value来解题

## 4.递归
- 1.二叉树
- 2.回溯

### 4.1.二叉树
1.递归算法表现上是解决两个问题:<br>
- 1.终止条件
- 2.递归过程

2.递归算法的构成条件是
- 1.子过程都有同样的特征,比如二叉树中每个节点也是二叉树

3.设计递归算法的思考过程是
- 1.确定当前函数解决的子问题是什么
- 2.当前函数接受下层提供的结果后,如何组合成当前结果返回给上层
