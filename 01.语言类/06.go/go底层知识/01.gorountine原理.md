# goroutine原理
经典的2个定义
goroutine是一个与其他goroutines并行运行在同一个地址空间go函数或方法。一个运行的函数又一个或多个goroutine组成。它与线程、协程、进程不同，它是一个goroutine。----Rob Pike
Goroutines在同一个用户地址空间并行独立执行functions。channels则用于goroutines之间的通信和同步访问控制。

![fail](https://cdn.jsdelivr.net/gh/pitifulnoble/picture@master/dff66ce90012ca84178cc16d5b668190.png)

## 问题：goroutine和thread线程有什么区别


- 1.内存占用：创建一个goroutine的栈内存消耗为2KB(Linux AMD64 Go v1.4后)，运行过程中，如果栈空间不够用，会自动进行扩容。
    - 创建一个thread为了尽量避免极端情况下操作系统线程栈的益处，默认会为其分配一个较大的栈内存(1-8MB栈内存，线程标准POSIX Thread)，而且还需要一个被称为"guard page"的区域用于和其他thread的栈空间进行隔离。二栈内存空间一旦创建和初始化完成之后其大小就不能再有变化，这决定了在某些特殊场景下系统线程栈还是有溢出风险。
- 2.创建/销毁：线程创建和销毁都会有巨大的开支，是内核级的交互
    - POSIX线程(定义了创建和操作线程的一套API)通常是在已有的进程模型中增加的逻辑扩展，所以线程控制和进程控制很相似。而进入内核调度所消耗的性能代价比较高，开销较大。goroutine是用户态"线程"，是由goruntine管理、创建和销毁的，消耗小很多。
- 3.调度切换：线程切换会消耗1000-1500纳秒(上下文保存成本高，较多寄存器，公平性，复杂时间计算统计)，一个纳秒平均可以执行12-18条指令。
    - 所以由于线程切换，执行指令数量减少12000-18000。goroutine的切换为200ns(用户态，3个寄存器)，相当于2400-3600条指令。因此，goroutines切换成本比threads小很多。
- 4.复杂性：线程的创建和退出复杂，多个thread间通信复杂
    - 不能大量创建线程，成本高，使用网络多路复用，存在大量callback(nginx的代码)。对于应用服务线程门槛高，例如需要做第三方库隔离，需要考虑接入线程池等。

    
## 问题：goroutine和thread关系
重要的M:N模型
![fail](https://cdn.jsdelivr.net/gh/pitifulnoble/picture@master/d3e715b1ff7e9dfbeec210858a33ce3d.png)
Go 创建M个线程(CPU执行调度单元，内核的task_struct)，之后创建N个goroutine都会依附在这M个线程上执行，即M:N模型。它们能够同时运行，与线程类似，但相比之下非常轻量。因此，程序运行时，goroutines的个数因该远大于线程的。
同一个时刻，一个线程只能跑一个goroutine。当goroutine发生阻塞(chan阻塞、mutex、syscall等等)时，go会把当前的goroutine调度走，让其他goroutine来继续执行，而不是让线程阻塞休眠，尽可能多的分发任务出去，让CPU忙碌。

## GMP调度模型
![fail](https://cdn.jsdelivr.net/gh/pitifulnoble/picture@master/28d97c9695f2aaee8490e8cc6adcdc10.png)
### 1.GMP各个对象介绍
- G：goroutine的缩写，每次go func()都代表一个G，无限制。
    - 使用struct runtime.g 包含了当前goroutine的状态，堆栈，上下文
- M：工作线程(OS thread)也被称为Machine，使用struct runtime.m，所有M是由线程栈的
    - 如果不对该线程栈提供内存的话，系统会给该线程提供内存(不同操作系统提供的线程栈大小不同)。当指定了线程栈，则M.stack->G.stack，M的PC寄存器指向G提供的函数，然后去执行。
- P："Processor"是一个抽象的概念，并不是真正的物理CPU。
    - Dmitry Vyukov的方案是引入一个结构P，它代表了M所需的上下文环境，也是处理用户级代码逻辑的处理器
    - 它负责衔接M和G的调度上下文，将等待执行的G与M对接。当P有任务时需要创建或者唤醒一个M来执行它队列里的任务。所以P/M需要进行绑定，构成一个执行单元。P决定了并行任务的数量，可通过runtime.GOMAXPROCS来设定。在Go1.5之后GOMAXPROCS被默认设置为可用的核数，而之前默认为1。

### 2.P的出现
早期版本只有GM调度模型，没有P。
引入了local queue，因为P的存在，runtime并不需要做一个集中式的goroutine调度，每一个M都会在P‘s local queue、global queue或者其他P队列中找G执行，减少全局锁堆性能的影响。
这也是CMP Work-stealing调度算法的核心。注意P的本地G队列还是可能面临一个并发访问的场景，为了避免加锁，这里P的本地队列是一个LockFree的队列，窃取G时使用CAS原子操作来完成。关于lockFree和CAS的知识参加: https://yizhi.ren/2017/09/19/reorder/

### 3.窃取
当一个P执行玩本地所有的G之后，并且全局队列为空的时候，会尝试挑选一个受害者P，从它的G队列中窃取一半的G。
为了保证公平性，从随机位置上的P开始，并且遍历顺序也随机化了(选择一个小与GOMAXPROCS，且和它互为质数的步长)，保证遍历的顺序也随机化了。
如果每次都只从自己的P队列查找G，可能会导致全局队列饥饿。P的调度算法还会每个N轮调度之后，去全局队列拿一个G

### 4.谁的G会被放回全局队列中呢
新建G时P的本地G队列放不下已满并达到256个的时候，会放半数G到全局队列去，阻塞的系统调用返回时找不到空闲P也会放到全局队列。

### 5.P阻塞在Syscall时
G调用syscall后，G会和P解绑，P和M解绑，然后M和G进入阻塞，而P此时的状态就是syscall，表明这个P的G正在syscall中，这时P是不能被调度给别的M的。如果短时内阻塞的M就唤醒了，那么M会优先重新获取这个P，能获取到就继续绑回去，这样有利于数据的局部性。
系统监视器(system monitor)，称为sysmon，会定时扫描。在执行syscall时，如果某个P的G执行超过一个sysmon tick(10ms)，就会把它设为idle，重新调度给需要的M，强制解绑。
P1和M脱离后目前在idle list中等待被绑定(处于syscall状态)。而syscall结束后M按照如下规则执行直到满足其中一个条件：
- 尝试获取同一个P(P1)，恢复执行G
- 尝试获取idle list中的其他空闲P，恢复执行G
- 找不到空闲P，把G放回global queue，M放回到idle list

当使用了Syscall，Go无法限制Blocked OS threads的数量：
Tips：**使用syscall写程序要认真考虑pthread exhaust问题**

### 6.线程自旋
线程自旋是相对于线程阻塞而言的，表现就是循环执行一个指定逻辑(调度逻辑，目的是不停的寻找G)。这样做的问题显而易见，如果G迟迟不来，CPU会白白浪费在这无意义的计算上。但好处也很明显，降低了M的上下文切换成本，提高性能。在2个地方引入自旋：
- 类型1:M不带P的找P挂载(一有P释放就结合)
- 类型2:M带P的找G运行(一有runable的G就执行)

为例避免过多浪费CPU资源，自旋的M最多允许GOMAXPROCS(Busy P)。同时当有类型1的自旋M存在时，类型2的自旋M就不阻塞，阻塞就会释放P，一释放P就马上被类型1的自旋M抢走了，没必要。

在新G被创建、M进入系统调用、M从空闲被激活这三种状态变化前，调度器会确保至少有一个自旋M存在(唤醒或者创建一个M)，除非没有空闲的P。
- 当新G创建，如果有可用P，就意味着新G可以被立即执行，即便不在同一个P也无妨，所以我们保留一个自旋的M(这时应该不存在类型1的自旋只有类型2的自旋)就可以保证新G很快被运行。
- 当M进入系统调用，意味着M不知道何时可以醒来，那么M对应的P中剩下的G就得有新的M来执行，所以我们保留一个自旋的M来执行剩下的G(这时应该不存在类型2的自旋只有类型1的自旋)。
- 如果M从空闲变成活跃，意味着可能一个处于自旋状态的M进入工作状态了，这时要检查病确保还有一个自旋M存在，以防还有G或者还有P空着的。

### 7.GMP问题总结
- 单一全局互斥锁(Sched.Lock)和集中状态存储
    - G被分成全局队列和P的本地队列，全局队列依旧是全局锁，但是使用场景明显减少，P本地队列使用无锁队列，使用原子操作来面对可能的并发场景
- Goruotine传递问题
    - G创建时就在P的本地队列，可以避免在P之间传递(窃取除外)，G对P的数据局部性好；当G开始执行了，系统调用返回后M会尝试获取可用P，获取到了的话可以避免P在M之间传递，而且有限获取调用阻塞前的P，所以G对M数据局部性好，G对P的数据局部性也好
- Per-M持有内存缓存(M.mcache)
    - 内存mcache只存在P结构中，P最多只有GOMAXPROCS个，远小于M的个数，所以内存没有过多的消耗。
- 严重的线程阻塞/解锁
    - 通过引入自旋，保证任何时候都有处于等待状态的自旋M，避免在等待可用的P和G时频繁的阻塞和唤醒。

    
## sysmon
sysmon也叫监控线程，它无需P也可以运行，它是一个死循环，没20us~1-ms循环一次，循环完一次就sleep一会，为什么是一个变动的周期呢，主要是避免空转，如果每次循环都没什么事情做，那么sleep时间就会变长。
- 释放闲置超过5分钟的span物理内存
- 如果超过2分钟没有垃圾回收，强制执行
- 将长时间未处理的netpoll添加到全局队列
- 向长时间运行的G任务发出抢占调度
- 收回因syscall长时间阻塞的P