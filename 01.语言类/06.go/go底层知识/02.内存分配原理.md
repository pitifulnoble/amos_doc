# 内存分配原理
go语言也有堆和栈概念。变量的存储位置是堆还是栈？
从正确的角度来看，你不需要知道。Go中的每个变量只要有引用就会一直存在。变量的存储位置(堆还是栈)和语言的语意无关。
存储的位置对于写出高性能的程序确实有影响。如果可能，Go编译器将为该函数的栈帧(stack frame)中的函数分配本地变量。但是如果编译器在函数返回无法证明变量未被引用，则编译器必须在会被垃圾回收的堆上分配变量以避免悬空空指针错误。此外，如果局部变量非常大，将它存储在堆上而不是栈上可能更有意义。

## 逃逸
### 1.逃逸分析
**通过检查变量的作用域是否超出了它所在的栈来决定是否将它分配在堆上**的技术。
其中**变量的作用域超出了它所在的栈**这种行为被称为逃逸。
逃逸属于静态分析：在编译期由静态代码分析来决定一个值是否能分配在栈帧上，还是需要**逃逸**到堆上。
- 减少GC压力，栈上的变量，随着函数推出后系统直接回收，不需要标记后再清除
- 减少内存碎片的产生
- 减轻分配堆内存的开销，提高程序的运行速度

### 2.逃逸案例
比较典型的是**多级间接赋值容易导致逃逸**，这里的多级间接指的是，对某个引用类对象中的引用类成员进行赋值(记住公式：Data.Field = Value, 如果Data.Field都是引用类的书籍类型，则会导致Value逃逸。这里的等号=不单单只是赋值，也表示参数传递)。Go语言中的引用类书籍类型有func、interface、slice、map、chan、*Type
- 一个值被分享到函数栈帧范围之外
- 在for循环外声明，在for循环内分配，同理闭包
- 发送指针或者带有指针的值到channel中
- 在一个切片上存储指针或带指针的值
- slice的背后数组被重新分配了
- 在interface类型上调用方法
- ...go build -gcflags '-m'

## 栈
### 1.连续栈
goroutine栈默认只有2k大小，当需要扩容的时候，采用复制栈的实现方式。
分配一个2倍大的内存块并把老的内存块内容复制到新的内存块里，当栈缩回之前大小时，我们不需要做任何事情。
- runtime.newstack 分配更大的栈内存空间
- runtime.copystack 将旧栈中的内容复制到新栈中
- 将指向旧栈对应变量的指针重新指向新栈
- runtime.stackfree 销毁并回收旧栈的内存空间

如果栈区的空间使用率不超过1/4，那么在垃圾回收的时候使用runtime.shrinkstack进行缩容，同样适用copystack

## 内存布局
### 1.概念
- page：内存页，一块8k大小的内存空间。Go与操作系统之间的内存申请和释放，都以page为单位
- span：内存块，一个或多个page组成一个span
- sizeclass：空间规格，每个span都带有一个sizeclass，标记着该span中的page应该如何使用
- object：对象，用来存储一个变量数据的内存空间，一个span在初始化时，会被切割成一堆等大object。假设object的大小时16B，span大小时8K，那么span中的page就会被初始化8K/16B=512个object