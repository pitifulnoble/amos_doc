# 问题

- Go Runtine的定义
- GO语言GMP 指什么？
- GO语言1.0之前的GM调度模型
- GO语言GMP调度流程
- GO语言GMP中Work Stealing机制
- GO语言GMP中Hand Off机制
- GO语言协作试的抢占调度
- GO语言基于信号的抢占试调度
- GO语言GMP调度过程中存在哪些阻塞
- GO语言Sysmon有什么作用
- GO语言三色标级原理
- GO语言插入写屏障
- GO语言删除写屏障
- GO语言写屏障
- GO语言混合写屏障
- GC触发机制
- GO语言中的GC的流程是什么
- GO语言GC如何调优


## Go Runtine的定义

在Go语言中，Goroutine是Go语言提供的一种轻量级的用户级线程。它是实现并发编程的核心概念，通过 go 关键字启动。Goroutine 的设计使得它比传统线程更加高效，能够支持大规模的并发操作。

Goroutine 的定义

	•	轻量级线程：每个 Goroutine 是一个由 Go runtime 管理的协程，它消耗的内存和资源非常小（初始栈空间仅为约 2KB，可动态增长）。
	•	并发执行：多个 Goroutine 可以在同一进程中独立运行，且由 Go runtime 自动调度和管理。
	•	启动方式：通过 go 关键字调用函数即可启动一个新的 Goroutine。

语法示例：

```
go functionName()
```

Goroutine 的工作原理

	1.	调度机制：
	•	Goroutine 运行在 Go 的调度器上，采用的是称为 GMP 模型 的调度算法：
	•	G：代表 Goroutine。
	•	M：代表操作系统线程。
	•	P：代表调度器上下文，负责在 Goroutine 和线程之间进行调度。
	•	Goroutine 的调度由 Go runtime 完成，无需开发者手动管理。
	2.	栈内存：
	•	Goroutine 的初始栈非常小（大约 2KB），并且会根据需要动态扩展或收缩。
	•	与操作系统线程相比，节省了大量内存，允许数以万计甚至数百万个 Goroutine 并发运行。
	3.	非抢占式调度：
	•	Go runtime 使用协作式调度（协程运行过程中主动让出控制权）和部分抢占式调度相结合的方式管理 Goroutine。
	•	比如 Goroutine 在执行 I/O 操作时会主动让出 CPU，而当运行时间过长时，runtime 也可能中断当前 Goroutine。

Goroutine 的使用示例

```
package main

import (
    "fmt"
    "time"
)

func sayHello() {
    for i := 0; i < 5; i++ {
        fmt.Println("Hello")
        time.Sleep(100 * time.Millisecond)
    }
}

func main() {
    // 启动一个 Goroutine
    go sayHello()

    // 主线程执行
    for i := 0; i < 5; i++ {
        fmt.Println("World")
        time.Sleep(100 * time.Millisecond)
    }
}
```

输出（可能的输出顺序，因并发行为不确定）：

```
World
Hello
World
Hello
World
Hello
...
```

Goroutine 与线程的区别

|特性|	Goroutine|	操作系统线程|
|---|------|-----|
|启动开销|	极低（2KB 栈）|	较高（约1MB 栈）|
|切换开销|	较低，由用户态完成|	较高，需要进入内核态|
|调度方式|	由 Go runtime 调度|	由操作系统调度|
|数量支持|	可支持数十万甚至更多|	数量受操作系统资源限制|
|栈大小|	动态调整，节省内存|	固定或有限的动态调整|

注意事项

	1.	主线程退出：
	•	如果主 Goroutine 退出，所有其他 Goroutine 也会退出。
	•	可以使用 sync.WaitGroup 或 channel 来确保 Goroutine 正常完成。
示例：

```
package main

import (
    "fmt"
    "sync"
)

func sayHello(wg *sync.WaitGroup) {
    defer wg.Done() // 确保任务完成时减少计数
    fmt.Println("Hello, Goroutine!")
}

func main() {
    var wg sync.WaitGroup
    wg.Add(1) // 增加等待计数
    go sayHello(&wg)
    wg.Wait() // 等待所有任务完成
}
```

	2.	资源同步：
	•	Goroutine 之间共享内存，需要通过互斥锁（sync.Mutex）或通信机制（channel）来避免数据竞争。
	3.	死锁和泄漏：
	•	小心死锁（多个 Goroutine 相互等待资源）和 Goroutine 泄漏（未终止的 Goroutine 持续占用资源）。

总结

Goroutine 是 Go 并发编程的基础，其轻量、高效的特性使得 Go 语言在处理大规模并发任务时具有显著优势。在实际开发中，充分理解 Goroutine 的运行机制和合理使用同步工具，可以帮助开发者构建高性能的并发程序。

## GO语言GMP 指什么？

在 Go 语言中，GMP 是其高效并发模型的核心设计，代表 Goroutine（G）、Machine（M）、Processor（P） 三个概念。这些概念共同组成了 Go 运行时的调度器，负责高效管理和调度 Go 的并发任务。

以下是对 GMP 模型的详细解释：

1. Goroutine (G)

	•	定义：Goroutine 是 Go 语言中的轻量级线程，每个 Goroutine 代表一个执行单元（任务）。
	•	特点：
	•	创建成本低：相比操作系统线程，创建 Goroutine 的开销非常小。
	•	内存占用少：每个 Goroutine 初始只需要 2KB 栈内存，可按需增长。
	•	数量多：可以轻松创建数以万计的 Goroutine。
	•	作用：
Goroutine 是程序中具体执行代码的逻辑单元，它们被调度到系统线程上运行。

2. Machine (M)

	•	定义：M 表示系统线程，M 是运行 Goroutine 的实际执行者。
	•	特点：
	•	每个 M 绑定一个系统线程（OS 线程）。
	•	通过 M，Goroutine 的代码能够真正运行在 CPU 上。
	•	作用：
M 负责将 G 映射到操作系统线程中运行。

3. Processor (P)

	•	定义：P 是逻辑处理器，负责调度和执行 G。
	•	特点：
	•	P 是 Goroutine 调度的核心组件。
	•	P 和 M 配合完成 Goroutine 的运行。
	•	P 的数量由 GOMAXPROCS 决定，可以通过 runtime.GOMAXPROCS(n) 调整。
	•	作用：
	•	每个 P 维护一个本地 Goroutine 队列，负责管理要执行的 G。
	•	P 负责将 G 分配给 M 来运行。

GMP 的工作原理

	1.	G 的调度：
Goroutine 被 P 负责调度，P 将从其本地队列中选择一个 G 来执行。
	2.	M 的作用：
M 是实际运行代码的执行载体。P 将 G 分配给 M，M 通过系统线程真正运行 G 的代码。
	3.	协作机制：
	•	M 运行 Goroutine，但不能脱离 P。
	•	如果 G 数量很多且当前 P 无法处理，则 Go 运行时会通过 M 和 P 动态协作（例如工作窃取）优化调度效率。
	4.	调度器策略：
	•	Go 的 GMP 模型采用 抢占式调度 和 非阻塞 I/O，确保 Goroutine 高效执行。
	•	运行时会在系统调用等场景下自动平衡 G 和 P 之间的关系。

GMP 的优势

	•	高效并发：通过 Goroutine 和 GMP 模型，Go 能支持大量并发任务。
	•	简单易用：开发者无需显式管理线程和锁，GMP 模型在底层自动完成复杂的调度工作。
	•	跨平台性能：Go 的调度器适配多核 CPU，能够充分利用硬件资源。

图示（简化版）

```
Goroutines (G)
  ↓
Processor (P) -- 调度器
  ↓
Machine (M) -- 系统线程
  ↓
CPU
```

通过这种设计，Go 实现了高效且易用的并发编程能力。

## GO语言1.0之前的GM调度模型

在 Go 语言 1.0 发布之前，Go 的运行时使用的是 GM 调度模型，相比于 Go 1.0 之后的 GMP 模型，GM 模型的设计较为简单，但在性能和可扩展性上存在一些问题。这是 Go 语言团队在早期阶段的一种尝试性实现。

GM 调度模型的结构

	•	G (Goroutine): 表示轻量级线程，类似于协程（Coroutine）。
	•	M (Machine): 表示系统线程（OS Thread），实际运行 Goroutine 的执行单元。

GM 模型的特点

	1.	一对多的关系：
	•	在 GM 模型中，多个 G（Goroutine）由一个 M（系统线程）负责运行。
	•	调度器将 G 分配到 M 上运行。
	2.	全局 Goroutine 队列：
	•	Goroutine 的分配依赖于一个全局的队列。
	•	所有的 M 从这个全局队列中取 Goroutine 来执行。
	3.	直接绑定线程：
	•	G 的执行直接依赖于 M，而 M 是绑定到系统线程的。
	•	如果 M 阻塞，例如因为 I/O 操作或系统调用，所有绑定到该 M 的 G 也会被阻塞。
	4.	没有逻辑处理器 (P)：
	•	GM 模型中没有 P 的概念，因此缺乏对 Goroutine 调度的精细控制。
	•	调度器的实现较为简单。

GM 模型的问题

	1.	性能瓶颈：
	•	由于所有的 Goroutine 共享一个全局队列，多个线程同时访问全局队列时会导致锁竞争，影响性能。
	2.	阻塞问题：
	•	如果某个 M 阻塞（如系统调用），该 M 上的所有 G 都会被阻塞，无法有效利用多核 CPU。
	3.	扩展性差：
	•	GM 模型难以充分利用多核 CPU，尤其是在处理大量 Goroutine 时调度效率较低。
	4.	调度开销高：
	•	缺乏 P（逻辑处理器）来分摊调度任务，调度效率较低，难以应对高并发场景。

从 GM 到 GMP 的演进

为了克服 GM 模型的缺陷，Go 语言团队在 1.0 版本中引入了 GMP 模型：
	1.	增加逻辑处理器 (P)：
	•	P 的引入将 Goroutine 的管理从全局队列改为每个 P 的本地队列，减少了锁竞争。
	2.	分离 M 的阻塞问题：
	•	GMP 模型中，如果一个 M 阻塞，P 可以将绑定的 G 迁移到其他可用的 M 上继续执行。
	3.	多核利用：
	•	GMP 模型通过 GOMAXPROCS 控制逻辑处理器的数量，显著提升了多核利用率。
	4.	高效调度：
	•	GMP 支持工作窃取（Work Stealing），使 Goroutine 的调度更高效。

总结

GM 模型是 Go 语言早期实现的简单并发模型，虽然可以运行 Goroutine，但由于性能瓶颈、阻塞问题和扩展性不足等缺陷，不适合大规模并发场景。Go 1.0 引入的 GMP 模型通过增加 P 的概念和优化调度算法，大幅提升了 Go 运行时的并发性能，是 Go 能够成为高效并发语言的重要基础。

## GO语言GMP调度流程

在 Go 语言中，GMP 模型的调度流程是其并发性能的核心。通过 Goroutine（G）、逻辑处理器（P）、和系统线程（M）的协作，Go 实现了高效的任务调度和多核利用。以下是 GMP 调度流程的详细说明：

GMP 模型核心组件回顾

	1.	G (Goroutine)
Goroutine 是 Go 中的轻量级线程，表示需要执行的任务。
	2.	P (Processor)
逻辑处理器，负责调度和管理 Goroutine，每个 P 维护一个本地队列存储 Goroutine。
	3.	M (Machine)
系统线程，实际运行 Goroutine 的载体，P 和 G 的执行需要通过 M。

调度的核心流程

1. 创建 Goroutine

	•	当用户通过 go 关键字创建一个新的 Goroutine（G），G 会被添加到某个 P 的本地队列中。
	•	如果本地队列已满，多余的 G 会被放到全局队列中。

2. M 和 P 的绑定

	•	每个 M 必须绑定一个 P 才能执行 G。
	•	GOMAXPROCS 决定 P 的数量（也即逻辑 CPU 核心的最大使用量）。
	•	如果某个 M 被阻塞（如进行系统调用），P 可以解除绑定并与其他空闲 M 配对。

3. P 的本地队列调度

	•	P 维护一个本地队列存储待执行的 G。
	•	优先调度顺序：
	1.	从 P 的本地队列中取 Goroutine。
	2.	如果本地队列为空，从全局队列中获取 Goroutine。
	3.	如果全局队列也为空，则从其他 P 的本地队列中窃取 Goroutine（Work Stealing）。

4. M 执行 Goroutine

	•	P 将 G 分配给绑定的 M，M 执行 G 中的任务。
	•	每个 M 执行 G 时遵循以下过程：
	1.	如果 G 阻塞，M 会让出 P，避免阻塞整个系统。
	2.	执行结束后，M 从 P 的队列中获取下一个 G。

5. I/O 操作与系统调用的处理

	•	如果一个 G 在执行过程中因为 I/O 操作或系统调用被阻塞：
	•	M 会将当前 G 挂起，并切换到另一个 G。
	•	阻塞的 G 被放到一个等待队列中，待条件满足后再重新调度。

6. 垃圾回收的影响

	•	垃圾回收（GC）会暂停所有的 G，并将 M 用于 GC 的任务。
	•	GC 完成后，调度器恢复正常工作。

具体的调度流程（代码执行场景）

	1.	用户调用 go func()：
	•	一个新的 Goroutine（G）被创建，并放入 P 的本地队列。
	2.	P 调度 G：
	•	P 从其本地队列中选择一个 G，交给绑定的 M 执行。
	•	如果本地队列为空，从全局队列或其他 P 的队列窃取 G。
	3.	M 执行 G：
	•	M 执行分配的 Goroutine。如果 Goroutine 阻塞，M 将切换到另一个任务。
	4.	系统调用或 I/O 操作：
	•	如果 G 在执行过程中调用阻塞操作（如 I/O），M 会将 G 挂起并处理其他任务。
	5.	任务完成：
	•	G 执行结束，M 继续从 P 的队列中获取下一个 G。

调度优化：工作窃取 (Work Stealing)

当一个 P 的本地队列为空时，调度器允许 P 从其他 P 的队列中窃取 Goroutine。这种机制避免了某些线程闲置，而其他线程过载的问题。
	•	每次窃取时，从目标 P 的队列尾部获取 Goroutine。
	•	窃取操作在多核环境下有效提升了任务分配的平衡性。

调度过程图示

```
          +----------------+
          |   全局队列     | (存放多余的 G)
          +----------------+
                ↓
  +-------+     +---------+      +---------+
  |   P1  | --> |    P2   | -->  |    P3   |  (逻辑处理器)
  +-------+     +---------+      +---------+
      ↓               ↓                ↓
+-------+       +-------+        +-------+
|   M1  |       |   M2  |        |   M3  |  (系统线程)
+-------+       +-------+        +-------+
      ↓               ↓                ↓
  (运行 G)         (运行 G)         (运行 G)
```

总结

Go 的 GMP 调度流程是高度优化的，以下是其关键特性：
	1.	多级队列：本地队列与全局队列结合，减少锁竞争，提高调度效率。
	2.	工作窃取：通过从其他 P 的队列窃取任务，提升多核利用率。
	3.	阻塞处理：避免因单个 Goroutine 阻塞而影响整个系统的并发能力。
	4.	动态适应：结合抢占式调度和非阻塞 I/O，确保 Goroutine 高效执行。

这种设计让 Go 成为处理高并发任务的理想选择。
