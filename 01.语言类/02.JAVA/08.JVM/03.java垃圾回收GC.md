# java垃圾回收

## 1.找到垃圾
判断一个对象是否有用,就是垃圾回收机制的主要难题.<br>
常见方法:<br>
- 1.计数引用
- 2.可达性分析


### 1.1.引用计数算法
- 1.通过判断对象的引用树,是否可以被回收
- 2.每个对象实例都有一个计数器,当被引用时+1,引用销毁-1
- 3.任何引用计数为0的对象,可以被当作垃圾回收

#### 1.1.1.特点
- 1.速度快,开销小,基本不会打断程序运行
- 2.不能检测循环引用

### 1.2.可达性分析
还记得协议课程老师将的可达性分析吗?<br>

#### 1.2.1.可被当作pathRoot的引用
- 1.虚拟机栈中引用的对象(栈帧中的本地变量表)
- 2.方法区中的常量引用的对象
- 3.方法区中静态属性引用对象
- 4.Native方法引用对象
- 5.活跃线程引用对象


## 2.垃圾回收算法

### 2.1.标记清除算法
- 1.标记:从根集合进行扫描,对存活的对象标记
- 2.对堆内存从头到尾线性遍历,对不可达的对象清除

![fail](img/3.1.PNG)<br>

### 2.2.复制算法
- 1.将内存分为对象区和空白区
- 2.对象在对象区创建
- 3.执行清除算法,存活的对象被复制到空白区
- 4.将对象区的所有内容清除(变成空白区)

![fail](img/3.2.PNG)<br>

### 2.3.标记整理算法
- 1.标记:从根集合进行扫描,对存活的对象进行标记
- 2.清除:移动所有的对象,且按照内存地址依次排列,然后将末端地址之后的内存地址全部回收

![fail](img/3.3.PNG)<br>

### 2.4.分代收集算法
- 1.内存分为年轻代和老年代(java8之前,java8取消了老年代)
- 2.年轻代有一个Eden和两个Surviver区(8:1)
- 3.年轻代使用**复制算法** 又叫做MinorGC
- 4.老年代使用**标记整理算法** 又叫做FullGC

#### 2.4.1.调优参数
```
-XX:SurvivorRatio : Eden和Survivor内存大小的比值 默认8:1
-XX:NewRatio : 老年代和年轻代内存大小比值 默认大概2:1
-XX:MaxTenuringThreshold : 对象从年轻代晋升到老年代经过GC次数的最大阈值
```

#### 2.4.2.触发FullGC的条件
- 1.老年代空间不足
- 2.CMS GC时出现``promotion failed``,``concurrent mode failure``
- 3.MinorGC晋升到老年代的平均大小大于老年代的剩余空间
- 4.调用System.gc() 告知JVM进行回收,但不一定会回收



#### 2.4.3.stop-the-world
- 1.JVM由于执行GC而停止了应用进程的执行
- 2.任何一种GC算法中都会发生
- 3.多数GC优化通过减少stop-the-world发生的时间来提高程序性能

#### 2.4.4.safePoint
只有在safePoint才有可能运行GC<br>
- 1.分析过程中对象引用关系不会发生变化的点
- 2.产生safePoint的地方:方法调用;循环跳转;异常跳转;
- 3.safePoint的数量要适中

## 3.新生代垃圾回收器

### 3.1.JVM运行模式
- 1.server
- 2.client

![fail](img/3.4.PNG)<br>

