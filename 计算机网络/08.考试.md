# 面试
- 说说 tcp 的三次握手
- 首次握手隐患-syn 超时 泛洪攻击
- 说说 tcp 的四次挥手
- 为什么会有 time_wait 状态
- 服务器有大量 clouse_wait 状态原因
- tcp 和 udp 的区别
- 在浏览器地址栏输入 url，敲回车会发生什么
- get 请求和 post 请求的区别
- cookie 和 session 的区别
- http 和 https 的区别

## TCP 三次握手

TCP 建立连接的过程采用 “三次握手” 机制，具体如下 ：

第一次握手：客户端进程想要发送请求数据，先创建传输控制块 TCB，并向服务端发送连接请求报文。报文首部中同步位 SYN=1，同时选择一个初始化序列号 seq=x，此时 TCP 客户端进入 SYN-SENT 同步已发送状态。

第二次握手：TCP 服务器接收到连接请求报文后，如果同意连接，则向客户端发出连接确认报文。连接确认报文中 ACK=1，SYN=1，确认号位 ack=x+1，同时也要自己初始化一个序列号 seq=y，此时 TCP 服务器进程就进入 SYN-RECV 同步收到状态 。

第三次握手：TCP 客户端接收到 TCP 服务端的请求连接确认报文之后，还需要给服务端发出确认信息，以确保连接请求信息未失效。确认报文的 ACK=1，ack=y+1，自己的序列号为 seq=x+1，此时 TCP 连接建立，服务端和客户端都进入 ESTABLISHED 已建立连接状态。

进行三次握手的主要目的是为了确认双方的接收能力和发送能力是否正常，防止已失效的连接请求报文段突然又传送到服务端，从而产生错误.

## 首次握手隐患-syn 超时 泛洪攻击
TCP协议的首次握手（SYN）是建立可靠连接的第一步，但它也可能被利用为攻击目标，尤其是在 SYN 超时 和 SYN 泛洪攻击 中。以下是详细解释及对应防护措施。

1. 首次握手（SYN）的流程

在 TCP 三次握手中，首次握手是由客户端发送一个 SYN 包，服务端收到后进入 SYN_RECV 状态，并准备返回 SYN+ACK 包。直到三次握手完成，连接才算真正建立。

2. SYN 超时问题

如果客户端发送 SYN 后，服务端返回了 SYN+ACK 包，但客户端未进行后续的确认（ACK 包），服务端将会等待超时时间，连接维持在 SYN_RECV 状态。这会导致：
	•	资源占用：服务端需要为每个未完成的连接分配一定的内存和资源。
	•	大量未完成的连接可能耗尽系统资源，影响正常服务。

3. SYN 泛洪攻击（SYN Flood Attack）

(1) 攻击原理

	•	攻击者伪造大量虚假的源 IP 地址，向目标服务器发送大量 SYN 包。
	•	服务器在收到 SYN 包后会分配资源并进入 SYN_RECV 状态，等待客户端的 ACK 包。
	•	因为这些源 IP 是伪造的，ACK 包永远不会到达，导致服务器资源被占用直至超时。

(2) 攻击影响

	•	服务器资源耗尽：CPU、内存、网络连接等被占满。
	•	正常用户无法建立连接，导致拒绝服务（DoS）。

4. 防范措施

(1) SYN Cookie 技术

	•	原理：服务端在收到 SYN 包时，不直接分配资源，而是生成一个基于 SYN 数据的加密哈希值（Cookie），并在 SYN+ACK 包中返回。
	•	优点：只有真正的客户端会返回合法的 ACK 包，服务端在接收到合法的 ACK 后才分配资源。
	•	实现：大多数现代操作系统（如 Linux）已支持 SYN Cookie，可通过以下命令启用：

echo 1 > /proc/sys/net/ipv4/tcp_syncookies


(3) 调整 SYN 超时时间

	•	缩短 SYN 半连接的超时时间，减少资源占用时间：

echo 60 > /proc/sys/net/ipv4/tcp_synack_retries



(4) 使用防火墙

	•	配置防火墙（如 iptables）限制每秒接受的 SYN 包数量：

iptables -A INPUT -p tcp --syn -m limit --limit 10/s --limit-burst 20 -j ACCEPT


	•	或使用更高级的防护工具（如 fail2ban、DDoS Protection Systems）。


(6) 部署 DDoS 防护服务

	•	使用专业的 DDoS 防护服务（如 Cloudflare、AWS Shield）来过滤恶意流量。

5. 总结

	•	SYN 超时 问题本身是 TCP 协议设计中的正常现象，但若被滥用（如 SYN 泛洪攻击），可能导致拒绝服务。
	•	防护关键在于：
	1.	启用 SYN Cookie。
	2.	调整系统参数限制资源分配。
	3.	结合防火墙、负载均衡和专业防护工具。
	•	针对高并发和大规模攻击场景，推荐使用综合性防护方案，如结合硬件和云服务的 DDoS 防护体系。



## 说说 tcp 的四次挥手

TCP 的四次挥手是指在终止 TCP 连接时，客户端和服务器之间需要发送四个包来确认连接的断开，以下是详细过程：

**第一次挥手**

客户端发送 FIN 报文：当客户端的数据发送完毕后，会向服务器发送一个带有 FIN 标志位的报文段，其中 FIN=1，序列号 seq=u，此时客户端进入 FIN_WAIT_1 状态，表示客户端已经没有数据要发送给服务器了，但仍然可以接收服务器发送的数据。

**第二次挥手**

服务器发送 ACK 报文：服务器收到客户端的 FIN 报文后，会向客户端发送一个 ACK 报文段作为应答，该报文段中 ACK=1，确认号 ack=u+1，序列号 seq=v，然后服务器进入 CLOSE_WAIT 状态。此时的 TCP 连接处于半关闭状态，即客户端到服务器的连接已经关闭，服务器不再接收客户端发送的数据，但服务器到客户端的连接仍然保持开放，服务器还可以继续向客户端发送数据。

**第三次挥手**

服务器发送 FIN 报文：当服务器的数据也发送完毕后，会向客户端发送一个带有 FIN 标志位的报文段，其中 FIN=1，ACK=1，序列号 seq=w，确认号 ack=u+1，然后服务器进入 LAST_ACK 状态，表示服务器已经准备好关闭连接了，等待客户端的最后确认。

**第四次挥手**

客户端发送 ACK 报文：客户端收到服务器的 FIN 报文后，会向服务器发送一个 ACK 报文段作为应答，该报文段中 ACK=1，seq=u+1，ack=w+1，然后客户端进入 TIME_WAIT 状态。此时客户端会等待 2MSL（Maximum Segment Lifetime，最大段生存时间）的时间，以确保服务器能够收到客户端发送的 ACK 报文，并且网络中所有与该连接相关的数据包都已经消失，防止出现延迟的数据包对新连接产生影响.

连接彻底关闭：服务器收到客户端的 ACK 报文后，就知道可以正式断开连接了，于是进入 CLOSED 状态。而客户端在等待 2MSL 时间后，如果没有收到服务器的重传请求，也会自动进入 CLOSED 状态，至此，TCP 连接彻底关闭

## 为什么会有 time_wait 状态

**防止旧连接的数据包干扰新连接**

网络环境中存在数据包延迟的情况，在 TCP 连接关闭过程中，可能会有一些属于旧连接的数据包仍在网络中传输。这些延迟的数据包可能会在新连接建立后到达新连接的接收端，从而干扰新连接的数据传输，造成混淆和错误。
通过设置 TIME-WAIT 状态并等待 2MSL 时间，能够保证在这段时间内，旧连接上所有可能存在的数据包都会因为超过最大段生存时间（MSL）而被丢弃，使得新连接不会受到旧连接数据包的干扰，确保新连接数据传输的准确性和稳定性。


**确保被动关闭端收到最后的ACK**
在第四次挥手时，客户端发送 ACK 报文段以确认收到服务器发送的 FIN 报文段，告知服务器可以关闭连接了。然而，这个 ACK 报文段有可能在传输过程中丢失。如果没有 TIME-WAIT 状态和 2MSL 的等待时间，一旦 ACK 丢失，服务器由于迟迟未收到确认，会认为客户端没有收到自己的 FIN 报文段，进而会重新发送 FIN 报文段。

而当客户端处于 TIME-WAIT 状态并等待 2MSL 时间时，若收到服务器重新发送的 FIN 报文段，就可以再次发送 ACK 报文段进行确认，从而确保服务器最终能够收到确认信息，可靠地关闭连接。

## 服务器有大量 clouse_wait 状态原因

**业务逻辑导致的延迟关闭**

数据处理未完成：有时候服务器收到客户端的 FIN 报文后，虽然确认了客户端不再发送数据，但自身可能还有一些与该客户端相关的数据处理任务没有完成。比如，服务器需要对之前接收自该客户端的数据进行持久化存储、数据分析等操作，在这些操作完成之前，不能轻易关闭与该客户端的连接，所以会保持在 CLOSE_WAIT 状态，等待数据处理完毕后再发送 FIN 报文关闭连接。

以一个电商订单处理系统为例，客户端发送订单提交的 FIN 报文后，服务器接收到并确认，但服务器可能还需要将订单数据同步到数据库、进行库存核对等一系列操作，在这些操作完成之前，连接就会处于 CLOSE_WAIT 状态。


## tcp 和 udp 的区别

TCP（Transmission Control Protocol）和 UDP（User Datagram Protocol）是两种常见的传输层协议，它们的主要区别在于是否提供可靠的数据传输、连接方式以及适用场景。以下是它们的主要区别：

1. 是否可靠

	•	TCP：
	•	提供可靠的数据传输。
	•	有错误检测、数据重传、确认机制，确保数据按顺序、无遗漏地到达目标。
	•	适用于需要高可靠性的应用，如文件传输、电子邮件、网页浏览。
	•	UDP：
	•	提供不可靠的数据传输。
	•	没有数据确认和重传机制，可能出现数据丢失、乱序或重复。
	•	适用于对实时性要求高且能容忍少量数据丢失的场景，如视频会议、在线游戏、DNS 查询。

2. 是否连接

	•	TCP：
	•	是面向连接的协议。
	•	在传输数据前，需通过三次握手建立连接，传输完成后需通过四次挥手断开连接。
	•	建立和关闭连接的过程增加了延迟。
	•	UDP：
	•	是无连接的协议。
	•	不需要建立和维护连接，发送数据包时只需知道目标地址和端口即可。
	•	更加轻量级，效率更高。

3. 数据传输方式

	•	TCP：
	•	面向字节流（Stream-oriented）。
	•	数据被分割成数据段，按序发送，并确保接收方以正确顺序接收。
	•	UDP：
	•	面向报文（Message-oriented）。
	•	每个数据包独立发送，接收方可能接收到的顺序与发送顺序不同。

4. 数据传输效率

	•	TCP：
	•	因为有连接管理、确认机制和重传功能，数据传输效率较低。
	•	消耗更多的系统资源。
	•	UDP：
	•	没有额外的连接管理和重传机制，开销小，传输效率高。
	•	适合高并发和实时性要求高的场景。

5. 适用场景

特性	TCP 应用场景	UDP 应用场景
可靠性高	文件传输（FTP）、HTTP、电子邮件（SMTP）	实时视频、语音通话、在线游戏
实时性高	-	DNS 查询、广播、多播
连接管理	长连接（如 HTTP/1.1 Keep-Alive）	短时间高频率传输

6. 流量控制与拥塞控制

	•	TCP：
	•	支持流量控制（防止发送方发送过快导致接收方缓冲区溢出）。
	•	支持拥塞控制（防止网络拥堵导致数据传输失败）。
	•	UDP：
	•	无流量控制和拥塞控制机制，发送方可以持续发送数据，不考虑接收方状态。

7. 头部开销

	•	TCP：
	•	TCP 报文头部较复杂，最小 20 字节，包含序列号、确认号、窗口大小等字段。
	•	UDP：
	•	UDP 报文头部简单，固定 8 字节，仅包含源端口、目标端口、长度和校验和。

总结

|特点|	TCP|	UDP|
|---|----|----|
|是否可靠|	是|	否|
|连接方式|	面向连接	|无连接|
|传输效率	|较低	|较高|
|传输单位|	字节流|	报文|
|适用场景|	高可靠性需求（如文件传输、HTTP）|	高实时性需求（如视频会议、DNS）|

根据场景需求选择 TCP 或 UDP 是关键，可靠性和实时性是两者的主要权衡点。


## cookie 和 session 的区别

Cookie 和 Session 是两种常用的机制，用于在客户端和服务端之间保存和传递用户状态信息。它们的主要区别在于存储位置、管理方式和安全性。以下是详细比较：

1. 存储位置

	•	Cookie：
	•	数据存储在客户端（浏览器）。
	•	每次请求时，浏览器会自动将 Cookie 数据发送到服务端。
	•	Session：
	•	数据存储在服务端，客户端只保存一个唯一的 Session ID（通常通过 Cookie 或 URL 参数传递）。
	•	服务端通过 Session ID 找到对应的用户状态信息。

2. 生命周期

	•	Cookie：
	•	生命周期可以由开发者设置（通过 Expires 或 Max-Age 属性）。
	•	可以是会话级（浏览器关闭即失效）或持久化（直到过期时间）。
	•	Session：
	•	默认是会话级的（用户关闭浏览器后，Session 通常失效）。
	•	也可以通过配置让 Session 持久化（如存储在数据库中）。

3. 数据大小

	•	Cookie：
	•	单个 Cookie 的大小限制为 4KB 左右（不同浏览器略有不同）。
	•	一般用于存储少量数据。
	•	Session：
	•	数据存储在服务端，大小通常只受服务端存储能力的限制。

4. 安全性

	•	Cookie：
	•	容易被用户查看和篡改，敏感数据不应直接存储在 Cookie 中。
	•	可以通过 HttpOnly 和 Secure 标志提高安全性（防止 JavaScript 访问和非 HTTPS 传输）。
	•	Session：
	•	相对安全，因为数据存储在服务端，客户端只能访问到一个无意义的 Session ID。
	•	如果 Session ID 被截获（如通过网络嗅探），可能导致会话劫持。

5. 使用场景

	•	Cookie：
	•	适用于存储一些无需保密的用户偏好设置或少量数据，如语言选择、主题设置等。
	•	常用于客户端本地存储。
	•	Session：
	•	适用于需要存储敏感信息或与用户会话相关的临时状态数据，如登录状态、购物车信息等。
	•	常用于需要更高安全性的场景。

6. 性能

	•	Cookie：
	•	由于每次请求都会随 HTTP 请求发送，过多的 Cookie 会增加带宽开销。
	•	处理速度依赖于客户端。
	•	Session：
	•	存储在服务端，对服务端内存或存储资源有一定开销，尤其在高并发情况下。
	•	需要使用合适的 Session 管理策略（如分布式存储、过期清理）。

7. 浏览器限制

	•	Cookie：
	•	每个域名下最多存储 20-50 个 Cookie（视浏览器不同）。
	•	单个 Cookie 不能超过 4KB，总量有限制。
	•	Session：
	•	无此限制，但需要管理大量用户的会话信息。

总结对比表

| 特性 |	Cookie	| Session |
| --- | ----- | ----- |
| 存储位置|	客户端 |	服务端 |
|生命周期 |	可设置过期时间 |	默认会话级，或配置持久化|
|大小限制 |	4KB（每个 Cookie）|	服务端存储能力决定|
|安全性 |	较低，易被篡改，需加密或保护 |	较高，数据存储在服务端|
|性能影响 |	每次请求都会传输，影响带宽 |	存储在服务端，占用内存或硬盘资源|
|适用场景 |	客户端偏好设置、简单数据存储 |	用户登录状态、敏感或复杂数据存储|

使用建议

	•	Cookie：
	•	存储不敏感、较小的数据。
	•	使用 HttpOnly 和 Secure 提高安全性。
	•	Session：
	•	用于存储敏感或会话相关数据，如用户认证信息。
	•	在分布式系统中，考虑使用 Redis 或数据库等持久化方案管理 Session。
